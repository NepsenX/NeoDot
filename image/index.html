<html>
<head>
  <meta name="viewport" content="width=device-width; height=device-height;">
  <link rel="stylesheet" href="resource://content-accessible/ImageDocument.css">
  <title></title>
    <style>  
        .loading {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            text-align: center;
        }
        
        .shrinkToFit {
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
            display: none; /* Hidden until loaded */
        }
        
        canvas {
            max-width: 100vw;
            max-height: 100vh;
            object-fit: contain;
            display: none;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading image...</div>
    <img class="shrinkToFit" id="generatedImage">
    <canvas id="processedCanvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            const img = document.getElementById('generatedImage');
            const canvas = document.getElementById('processedCanvas');
            const loading = document.getElementById('loading');
            const ctx = canvas.getContext('2d');
            
            // Get URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const text = urlParams.get('text');
            const model = urlParams.get('model');
            const size = urlParams.get('size');
            const userUrl = urlParams.get('url');
            const seed = urlParams.get('seed');
            
            if (!text) {
                loading.textContent = 'Error: No text prompt provided';
                return;
            }
            
            // Set page title to prompt
            document.title = text;
            
            // Generate random seed if not provided (1 to 999999)
            const finalSeed = seed || Math.floor(Math.random() * 999999) + 1;
            
            try {
                // Step 1: Always get enhanced prompt from OpenAI for all categories
                const openaiPromptUrl = `https://text.pollinations.ai/write_only_prompt_for_the_user_image:${encodeURIComponent(text)}?model=openai-fast`;
                const promptResponse = await fetch(openaiPromptUrl);
                
                if (!promptResponse.ok) {
                    throw new Error('OpenAI prompt enhancement failed');
                }
                
                const enhancedPrompt = await promptResponse.text();
                const finalPrompt = enhancedPrompt || text;
                
                // Step 2: Build image URL based on the three main scenarios
                let imageUrl;
                const token = "vHigSh5nPMrSeQbx";
                const noWatermark = "&nofilter=1"; // This removes the watermark
                
                if (userUrl) {
                    imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}?model=nanobanana&url=${encodeURIComponent(userUrl)}&seed=${finalSeed}&enhance=true&token=${token}${noWatermark}`;
                }
                else if (model) {
                    if (model === 'flex' || model === 'turbo') {
                        imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}?model=${model}&seed=${finalSeed}&enhance=true${noWatermark}`;
                    } else {
                        imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}?model=${model}&seed=${finalSeed}&enhance=true&token=${token}${noWatermark}`;
                    }
                }
                else {
                    // Try nanobanana first
                    imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}?model=nanobanana&seed=${finalSeed}&enhance=true&token=${token}${noWatermark}`;
                
                    try {
                        const res = await fetch(imageUrl, { method: "HEAD" });
                        if (!res.ok) {
                            // If nanobanana fails, try seedream
                            imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}?model=seedream&seed=${finalSeed}&enhance=true&token=${token}${noWatermark}`;
                            const res2 = await fetch(imageUrl, { method: "HEAD" });
                
                            if (!res2.ok) {
                                // If seedream also fails, fallback to flex (no token)
                                imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}?model=flex&seed=${finalSeed}&enhance=true${noWatermark}`;
                            }
                        }
                    } catch (err) {
                        // In case of network error, fallback directly to flex
                        imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}?model=flex&seed=${finalSeed}&enhance=true${noWatermark}`;
                    }
                }

                // Add size parameter if provided
                if (size) {
                    const preset = sizePresets[size.toLowerCase()] || sizePresets.default;
                    
                    // If size is a preset name, use its dimensions
                    if (sizePresets[size.toLowerCase()]) {
                        imageUrl += `&width=${preset.width}&height=${preset.height}`;
                    } 
                    // If size is a custom number, use it for both width and height
                    else if (!isNaN(size)) {
                        imageUrl += `&width=${size}&height=${size}`;
                    }
                    // If size is in format "WxH" (e.g., "800x600")
                    else if (size.includes('x')) {
                        const [width, height] = size.split('x');
                        imageUrl += `&width=${width}&height=${height}`;
                    }
                    // Default fallback
                    else {
                        imageUrl += `&width=${preset.width}&height=${preset.height}`;
                    }
                }
                
                // Load and process image for watermark removal
                loading.textContent = 'Processing image and removing watermark...';
                
                const response = await fetch(imageUrl);
                if (!response.ok) {
                    throw new Error('Failed to load image');
                }
                
                const blob = await response.blob();
                const originalImageUrl = URL.createObjectURL(blob);
                
                const tempImg = new Image();
                tempImg.src = originalImageUrl;
                
                tempImg.onload = function() {
                    // Calculate crop - adding 1-2px extra to bottom only
                    const cropRight = Math.min(tempImg.width * 0.05, 100);
                    const cropBottom = Math.min(tempImg.height * 0.05, 100) + 12; // Added 2px extra
                    
                    canvas.width = tempImg.width - cropRight;
                    canvas.height = tempImg.height - cropBottom;
                    
                    // Draw original image (cropped)
                    ctx.drawImage(
                        tempImg, 
                        0, 0, 
                        canvas.width, canvas.height,
                        0, 0,
                        canvas.width, canvas.height
                    );
                    
                    // Enhanced watermark removal
                    try {
                        // Check bottom-right 20x20px area for watermark
                        const watermarkCheckArea = ctx.getImageData(
                            canvas.width - 20,
                            canvas.height - 20,
                            20, 20
                        );
                        
                        let watermarkPixels = 0;
                        const data = watermarkCheckArea.data;
                        for (let i = 0; i < data.length; i += 4) {
                            // Detect semi-transparent white (common watermark color)
                            if (data[i] > 220 && data[i+1] > 220 && data[i+2] > 220 && data[i+3] > 100) {
                                watermarkPixels++;
                            }
                        }
                        
                        // If watermark detected in >25% of checked area
                        if (watermarkPixels > 100) {
                            // Cut additional 1px if needed
                            canvas.height -= 1;
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(
                                tempImg, 
                                0, 0, 
                                canvas.width, canvas.height,
                                0, 0,
                                canvas.width, canvas.height
                            );
                        }
                    } catch (e) {
                        console.log("Watermark detection error:", e);
                    }
                    
                    // Convert canvas to image and display
                    const processedImageUrl = canvas.toDataURL('image/png');
                    img.src = processedImageUrl;
                    
                    img.onload = function() {
                        // Hide loading, show image
                        loading.style.display = 'none';
                        img.style.display = 'block';
                        
                        // Set actual image dimensions
                        img.width = this.naturalWidth;
                        img.height = this.naturalHeight;
                        
                        // Clean up
                        URL.revokeObjectURL(originalImageUrl);
                    };
                };
                
                tempImg.onerror = function() {
                    loading.textContent = 'Error processing image';
                };
                
            } catch (error) {
                console.error('Error:', error);
                loading.textContent = 'Error: ' + error.message;
                
                // Ultimate fallback - try without processing
                const finalUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(text)}?model=flex&seed=${finalSeed}${noWatermark}${size ? `&width=${size}` : ''}`;
                img.onload = function() {
                    loading.style.display = 'none';
                    img.style.display = 'block';
                    img.width = this.naturalWidth;
                    img.height = this.naturalHeight;
                };
                img.onerror = function() {
                    loading.textContent = 'Failed to load image';
                };
                img.src = finalUrl;
            }
        });
        
        // Size presets object (you can add your 200+ presets here)
        const sizePresets = {
            youtube: { width: 1280, height: 720 },
            facebook: { width: 1200, height: 630 },
            instagram: { width: 1080, height: 1080 },
            default: { width: 800, height: 600 }
            // Add all your 200+ presets here...
        };
    </script>
</body>
</html>
